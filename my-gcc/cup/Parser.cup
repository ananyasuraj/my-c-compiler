package MyGCC;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.util.Map.Entry;

parser code {:

  public static Parser p;
  public static PrintStream ps;
  public static Boolean DEBUG = true;
  public static char currentReg = 'c';
  public CodeGenerator cg = new CodeGenerator();
  public RegisterManager regMan = new RegisterManager();

  Parser(Scanner s, SymbolFactory sf, PrintStream ps){
    super(s,sf);
    this.ps = ps;
  }

  public static void main(String args[]) throws Exception {
    SymbolFactory sf = new DefaultSymbolFactory();
    String destination_file;

    if (args.length >= 2)
      destination_file = args[1];
    else
      destination_file = args[0].substring(0,args[0].lastIndexOf('.')) + ".s";

    System.out.println("Writing to : " + destination_file);
    p = new Parser(new Scanner(new FileInputStream(args[0]),sf),
                               sf,
                               new PrintStream(destination_file));
    //System.out.println("modified version");
    //p.debug_parse();
    p.ps.println("\t.file \""+ args[0]+"\"\n\t.text\n");
    p.parse();
    p.ps.println(p.cg.generateCode());
    p.ps.close();
  }
  

  public static String getNextRegistry(){       
    String s = new String("$e" + currentReg + "x");
    currentReg++;
    return s; 
  }

  public void syntax_error(Symbol cur_token) { //overloads the default method
    report_error("*** Syntax Error at line "
                 + (cur_token.left+1)
                 + ", column "
                 + cur_token.right
                 + " ***",
                 null);
    p.debug_stack();
    p.debug_shift(cur_token);
  }
:}

terminal INT, VOID, STATIC, LHOOK, RHOOK, LPAREN, RPAREN, LBRACKET, RBRACKET,
         COMMA, SEMI, EQL, EXIT, RETURN, READ_INT, IF, ELSE, WHILE, MINUS,
         NOT, LESS, GREATER, EQUALS, LEQL, GEQL, DIFF, PLUS, TIMES, DIV, MOD,
         OR, AND;
    
terminal String IDENT;
terminal Integer NB_INT;

non terminal program, declarations_list, declaration, prototype,
             functions_list, function, header,
             parameter, body, instruct_list,
             arg_sequence, args_list, dec_func_list, dec_end, proto_func,
             hybrid_param, dec_or_func_end, arr, arr_proto;

non terminal Type type;
non terminal ArrayList<Type> types_list, types_sequence;
non terminal ArrayList<Entry<Type,String>> param_list, param_sequence;
non terminal String bin_op;
non terminal Expression expression;
non terminal Instruction instruction;


precedence left OR, AND;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence nonassoc EQUALS, DIFF, GREATER, LESS, LEQL, GEQL, IF, ELSE, NOT;

// A program is a list of declarations and functions
program ::= dec_func_list;

// Defines the structure of declarations and functions
dec_func_list ::=

    // Format for the declaration of a static variable, each declaration is
    // seperated by a semicolon
    STATIC type IDENT arr SEMI dec_func_list
    
    // Format for the declaration of a non-static variable, or a prototype
  | type:t IDENT:id
           {:
             if(Parser.DEBUG) System.out.println("Type : " + t);
             parser.cg.pushInformation(new ParsingResult<Type>(ResultType.TYPE,
                                                               t));
             if(Parser.DEBUG) System.out.println("Identifier : " + id);
             parser.cg.pushInformation(new ParsingResult<String>(ResultType.ID,
                                                                 id));
           :}dec_end
  
    // Format for the prototype of a function with void return type
  | VOID IDENT proto_func
  ;
        
// End of the declaration a non-static variable or of a function's prototype
dec_end ::=
    arr SEMI dec_func_list
  | proto_func
  ;
       
       
arr ::=
    // A declaration or a prototype may contain an Array of.
    // Therefore it wile be of the for [NUM]
    LHOOK NB_INT RHOOK
    // It may also be empty
  |                     
  ;
   
// Beginning of the parameters of a function's prototype
proto_func ::=
    LPAREN hybrid_param
  ;
      
// Format of the parameters of a function or prototype
hybrid_param ::=

    // A list of types ending with a semicolon, another declaration or
    // a function may follow
    types_list:typeList RPAREN SEMI
      {:
        if(Parser.DEBUG) System.out.println("Push Type List : " + typeList);
        parser.cg.pushInformation(new ParsingResult<ArrayList<Type>>(ResultType.PARAMETERS, typeList));
        parser.cg.declarePrototype();
      :}
    dec_func_list
    
    // List of the arguments for a function.
    // a function ends with a }
  | param_list:p RPAREN LBRACKET
      {:
        if(Parser.DEBUG) System.out.println("Push ParamList : " + p);
        parser.cg.pushInformation(new ParsingResult<ArrayList<Entry<Type,String>>>(ResultType.PARAMETERS,p));
        parser.cg.declareFunction();
        parser.cg.openFunction();
      :}
    body RBRACKET
      {:
        parser.cg.closeFunction();
      :}
    functions_list
  
    // The function may require no parameters, a declaration or function
    // may ensue
  | VOID RPAREN dec_or_func_end
  ;

// Describes the end of a Declaration or a Function
dec_or_func_end ::=

    // All declarations end with a semicolon, and may be
    // followed by either a function of a declarion
    SEMI
    {:
      parser.cg.declarePrototype();
    :}
    dec_func_list
    
    // If we have a function, it will be ended by { code }
    // And followed by a list of functions
  | LBRACKET body:b RBRACKET
                  {:
                    if(Parser.DEBUG) System.out.println("Push body : " + b);
                    parser.cg.pushInformation(b);
                    parser.cg.declareFunction();
                  :} functions_list
  ;

// Defines the constraints of a list of declarations
declarations_list ::=

    // All declarations are separated by a semicolon
    declaration SEMI declarations_list
  |
  ;
  
// Declaration of either a variable the prototype of a function.
declaration ::=

    // A declaration must contain a type (int, float, void, ect...)
    // an identifier (name of the variable of function)
    // and either an array, or the rest of a function's prototype

    type:t IDENT:id
         {: if(Parser.DEBUG) System.out.println("Push type : " + t);
            parser.cg.pushInformation(new ParsingResult<Type>(ResultType.TYPE, t));
            if(Parser.DEBUG) System.out.println("Push Identifier : " + id);
            parser.cg.pushInformation(new ParsingResult<String>(ResultType.ID, id)); :}
           arr_proto
    
    // A variable may be declared as static
  | STATIC type IDENT arr
  
    // a function may be have a VOID return type
  | VOID IDENT prototype
  ;
      
// Determines if we are dealing with the declaration of a variable
// or a prototype and reduces accordingly
arr_proto ::=
    arr {: parser.cg.declareVariable(); :}
  | prototype {: parser.cg.declarePrototype(); :}
  ;
      
// Definition of the part of a function's prototype that differs from
// the declaration of a variable
prototype ::=

    // Represent the types of the arguments the function will take
    LPAREN types_sequence RPAREN
  ;


type ::=
    INT:t {:RESULT = Type.INT;
            //parser.cg.pushInformation(new ParsingResult<String>(ResultType.TYPE, t));
          :}
  ;
    
// A sequence of types for the prototype of a function
types_sequence ::=

    // A function may require no arguments, type is VOID
    VOID
    
    // If the function requires arguments, it will be a types_list
  | types_list
  ;


// Used for defining the types required for the arguments of a function
types_list ::=
    type:t {: //RESULT = t; :}
    
    // each variable type is seperated by a comma
  | type:t {: //RESULT = t; :}  COMMA types_list
  ;
      
// List of functions. It may be empty
functions_list ::=
    function functions_list
  |
  ;
        
// Core structure of a function in C
function ::=
    header LBRACKET body RBRACKET
  ;

header ::=
    type IDENT LPAREN param_sequence RPAREN
  ;

// Determines whether the function requires any arguments
param_sequence ::=
    
    // The function requires no arguments
    VOID
    
    // The function requires at least one argument
  | param_list
  ;

// A list of parameters, each seperated by a comma.
param_list ::=

    // a param_list may contain a single parameter
    parameter
  | parameter COMMA param_list
  ;
      
// A parameter MUST be a variable
parameter ::=

    INT IDENT
    
    // The variable can be an array
  | INT IDENT LHOOK NB_INT RHOOK
  ;
     
// The body of a function is composed of declarations and instructions
body ::=
    declarations_list instruct_list
  ;

// A list of instructions, each separated by semicolons
instruct_list ::=
    instruction:i 
      {: parser.cg.handleInstruction(); :}
    SEMI instruct_list
  |
  ;
        
// Every instruction which can be performed
instruction ::=
    
    // Compare the value of a variable with that of an expression
    IDENT EQL expression:e
      {: if(Parser.DEBUG) System.out.println("instruction detected: EQL"); //TODO check state of expression
         parser.cg.pushInstruction(new Instruction(e, InstructionType.EQL)); :}
    
    // Compare the value of an item from an array with that of an expression
    // The index may be obtained with an expression
  | IDENT LHOOK expression RHOOK EQL expression
  
    // Exit with status NB_INT
  | EXIT LPAREN NB_INT:n RPAREN
      //{: parser.cg.pushInstruction(new Instruction(n, InstructionType.EXIT)); :}
      //TODO fix: constructor takes Expression as 1st argument, not Integer.
  
    // Return the value of an expression
  | RETURN expression:e
      {: if(Parser.DEBUG) System.out.println("push instruction : RETURN exp : " + e);
         parser.cg.pushInstruction(new Instruction(e, InstructionType.RETURN)); :}
  
    // Return no value
  | RETURN 
      {: if(Parser.DEBUG) System.out.println("push instruction: RETURN");
         parser.cg.pushInstruction(new Instruction(null, InstructionType.RETURN)); :}
  
    // Scanf(int)
  | READ_INT LPAREN IDENT RPAREN
  
    // Basic "if else" test on an expression
  | IF LPAREN expression RPAREN instruction ELSE instruction

    // Simple "if" test on an expression
  | IF LPAREN expression RPAREN instruction
  
    // Basic "while" instruction
  | WHILE LPAREN expression RPAREN instruction
  
    // Allow for the use of multiple instructions (for instance
    // after an if, or a while
  | LBRACKET instruct_list RBRACKET
  
  | expression:e
      {: if(Parser.DEBUG) System.out.println("instruction detected: exp");
         parser.cg.pushInstruction(new Instruction(e, null)); :} //OperationType instead of null?
  ;
        
// Defines the list of possible expressions to be used
expression ::=
    expression:left bin_op:op expression:right
      {: if(Parser.DEBUG) System.out.println("expression operator: " + op);
         RESULT = new ArithmeticResult<Expression>(op, left, right); :}

  | MINUS expression
  
  | NOT expression
  
  | LPAREN expression:e RPAREN
      {: RESULT = e; :}

  | IDENT:i
      {: if(Parser.DEBUG) System.out.println("expression ident: " + i);
         RESULT = new ArithmeticResult<String>(null, i);  :}

  | NB_INT:n
      {: if(Parser.DEBUG) System.out.println("expression: " + n);
         RESULT = new ArithmeticResult<Integer>(null, n); :}

    // Allows the use of a function in an expression
  | IDENT LPAREN arg_sequence RPAREN
      //{: RESULT = new FunctionResult(); :}
  
    // Allows the use of arrays with expression calculated indexes
  | IDENT LHOOK expression RHOOK
  ;
  
// Can be either empty, or a list of arguments
arg_sequence ::= 
    args_list
  |
  ;
        
// A list of expressions, each seperated by a comma
// An args_list may not be empty
args_list ::=
    expression
  | expression COMMA args_list
  ;
     
// List of accepted binary operators
bin_op ::=
    LESS
    {: RESULT = new String(OperationType.LESS.toString()); :}
  | GREATER
    {: RESULT = new String(OperationType.GREATER.toString()); :}
  | EQUALS
    {: RESULT = new String(OperationType.EQUALS.toString()); :}
  | LEQL
    {: RESULT = new String(OperationType.LEQL.toString()); :}
  | GEQL
    {: RESULT = new String(OperationType.GEQL.toString()); :}
  | DIFF
    {: RESULT = new String(OperationType.DIFF.toString()); :}
  | PLUS
    {: RESULT = new String(OperationType.ADD.toString()); :}
  | MINUS
    {: RESULT = new String(OperationType.SUB.toString()); :}
  | TIMES
    {: RESULT = new String(OperationType.MUL.toString()); :}
  | DIV
    {: RESULT = new String(OperationType.DIV.toString()); :}
  | MOD
    {: RESULT = new String(OperationType.MOD.toString()); :}  
  | OR
    {: RESULT = new String(OperationType.OR.toString()); :}
  | AND
    {: RESULT = new String(OperationType.AND.toString()); :}
  ;
     
